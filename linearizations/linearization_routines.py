################################################################################
# Routines that construct linearized approximations in the tradition of 
# Schmitt-Grohe and Uribe (2002 JEDC)
# 
# These programs were generated by ChatGPT, translating original functions 
# written by Chris Sims, Stephanie Schmitt-Grohe and Martin Uribe from MATLAB 
# to Python.   
# 
# TO DO: Check ALL of these routines. Once checked, see if there is a way to 
# make these routines JIT-compilable.
################################################################################

import numpy as np 
from scipy.linalg import qz, solve
from sympy import *

# First-order approximation to a model
def qzswitch(i, A, B, Q, Z):
    """
    Takes U.T. matrices A, B, orthonormal matrices Q, Z, interchanges diagonal
    elements i and i+1 of both A and B, while maintaining Q'AZ' and Q'BZ' unchanged.
    Does nothing if ratios of diagonal elements in A and B at i and i+1 are the same.
    Aborts if diagonal elements of both A and B are zero at either position.
    
    Parameters:
    i (int): index of diagonal element to be switched
    A (numpy.ndarray): U.T. matrix
    B (numpy.ndarray): U.T. matrix
    Q (numpy.ndarray): orthonormal matrix
    Z (numpy.ndarray): orthonormal matrix
    
    Returns:
    A (numpy.ndarray): updated U.T. matrix
    B (numpy.ndarray): updated U.T. matrix
    Q (numpy.ndarray): updated orthonormal matrix
    Z (numpy.ndarray): updated orthonormal matrix
    """
    
    # Get diagonal elements to be switched
    a = A[i, i]
    d = B[i, i]
    b = A[i, i+1]
    e = B[i, i+1]
    c = A[i+1, i+1]
    f = B[i+1, i+1]
    
    # Calculate wz and xy
    wz = np.array([c*e-f*b, (c*d-f*a)])
    xy = np.array([(b*d-e*a), (c*d-f*a)])
    
    # Check if diagonal elements are zero
    if a == 0 and b == 0:
        return A, B, Q, Z
    elif c == 0 and f == 0:
        return A, B, Q, Z
    
    # Calculate ratios of diagonal elements and check if they're the same
    if b == 0:
        r = np.inf
    else:
        r = a/b
    if e == 0:
        s = np.inf
    else:
        s = c/e
    
    if r == s:
        return A, B, Q, Z
    
    # Normalize wz and xy
    n = np.linalg.norm(wz)
    m = np.linalg.norm(xy)
    wz = wz / n
    xy = xy / m
    
    # Calculate final wz and xy
    wz = np.array([wz[0], -wz[1], wz[1], wz[0]])
    xy = np.array([xy[0], -xy[1], xy[1], xy[0]])
    
    # Update matrices A, B, Q, Z
    A[i:i+2,:] = xy @ A[i:i+2,:]
    B[i:i+2,:] = xy @ B[i:i+2,:]
    A[:,i:i+2] = A[:,i:i+2] @ wz
    B[:,i:i+2] = B[:,i:i+2] @ wz
    Z[:,i:i+2] = Z[:,i:i+2] @ wz
    Q[i:i+2,:] = xy @ Q[i:i+2,:]
    
    return A, B, Q, Z

def qzdiv(stake, A, B, Q, Z):
    """
    Takes U.T. matrices A, B, orthonormal matrices Q,Z, rearranges them
    so that all cases of abs(B(i,i)/A(i,i))>stake are in lower right 
    corner, while preserving U.T. and orthonormal properties and Q'AZ' and
    Q'BZ'.
    """
    n, jnk = A.shape
    root = np.abs(np.hstack((np.diag(A).reshape(-1, 1), np.diag(B).reshape(-1, 1))))
    root[:, 0] = root[:, 0] - (root[:, 0] < 1e-13) * (root[:, 0] + root[:, 1])
    root[:, 1] = root[:, 1] / root[:, 0]
    
    for i in range(n-1, -1, -1):
        m = 0
        for j in range(i, -1, -1):
            if (root[j, 1] > stake) or (root[j, 1] < -0.1):
                m = j
                break
        if (m == 0):
            return A, B, Q, Z
        
        for k in range(m, i):
            A, B, Q, Z = qzswitch(k, A, B, Q, Z)
            tmp = root[k, 1]
            root[k, 1] = root[k+1, 1]
            root[k+1, 1] = tmp
            
    return A, B, Q, Z

def solab_flag(a, b, NK, stake=1):
    # Upper triangular factorization of the matrix pencil b-za
    s, t, q, z = qz(a, b)
    
    # Reordering of generalized eigenvalues in ascending order
    s, t, q, z = qzdiv(stake, s, t, q, z)

    nk = sum(abs(np.diag(t)) < stake * abs(np.diag(s)))
    
    if nk > NK:
        # warning('The Equilibrium is Locally Indeterminate')
        exitflag = 2
    elif nk < NK:
        # warning('No Local Equilibrium Exists')
        exitflag = 0
    else:
        exitflag = 1

    z21 = z[nk:, :nk]
    z11 = z[:nk, :nk]

    if np.linalg.matrix_rank(z11) < nk:
        # warning('Invertibility condition violated')
        exitflag = 3

    s11 = s[:nk, :nk]
    t11 = t[:nk, :nk]

    dyn = solve(s11, t11)

    z11i = np.linalg.inv(z11)

    f = np.real(z21 @ z11i)
    p = np.real(z11 @ dyn @ z11i)

    return f, p, exitflag

def gx_hx(fy,fx,fyp,fxp,stake):
    '''
    Computes the matrices gx and hx that define the first-order approximation 
    of a DSGE model. That is, if

    E_t[f(yp,y,xp,x)=0 
    
    then the solution is of the form
    
    xp = h(x,sigma) + sigma * eta * ep
    y = g(x,sigma)
    
    The first-order approximations to the functions g and h around the point (x,sigma)=(xbar,0), 
    where xbar=h(xbar,0), are:
    
    h(x,sigma) = xbar + hx (x-xbar) 
    
    and
    
    g(x,sigma) = ybar + gx * (x-xbar),
    
    where ybar=g(xbar,0). 
    
    The exit flag takes the values 0 (no solution), 1 (unique solution), 2 (indeterminacy), or 3 (z11 is not invertible).
    
    Translation of gx_hx.m written by Stephanie Schmitt-Grohe and Martin Uribe, dated July 17, 2001, May 11 2006
    '''
    A = np.block([[-fxp, -fyp]])
    B = np.block([[fx, fy]])

    if stake is None:
        stake = 1

    gx, hx, exitflag = solab_flag(A, B, fx.shape[1], stake)
    return gx, hx, exitflag

def anal_deriv_first(f,x,xp,y,yp):

    # compute jacobians
    fx = f.jacobian(x)
    fxp = f.jacobian(xp)
    fy = f.jacobian(y)
    fyp = f.jacobian(yp)

    return fx,fxp,fy,fyp

# Routines for Symbolic Models
def RBCSym(params):

    # Extract parameters
    palpha,pbeta,psigma,pdelta,ppsi,pchin,prhoz,psigz,prhoa,psiga = [i for i in params]

    # Define variables
    # 1 = contemporaneous
    # 2 = forward
    Y1,C1,I1,K1,N1,z1,a1 = Symbol('Y1'),Symbol('C1'),Symbol('I1'),Symbol('K1'),Symbol('N1'),Symbol('z1'),Symbol('a1')
    Y2,C2,I2,K2,N2,z2,a2 = Symbol('Y2'),Symbol('C2'),Symbol('I2'),Symbol('K2'),Symbol('N2'),Symbol('z2'),Symbol('a2')

    # Model Equations: fully nonlinear model
    f1 = Y1 - exp(z1) * (K1 ** palpha) * (N1 ** (1-palpha)) 
    f2 = Y1 - C1 - I1
    f3 = K2 - K1*(1-pdelta) - I1 
    f4 = z2 - prhoz * z1
    f5 = a2 - prhoa * a1
    f6 = C1**(-psigma) - pbeta * ((palpha * Y2/K2) + (1-pdelta))* (C2 ** (-psigma))
    f7 = C1**(-psigma) * (1-palpha) * Y1/N1 - exp(a1) * (N1 ** (1/ppsi))
    f = Matrix([[f1],[f2],[f3],[f4],[f5],[f6],[f7]])

    # Evaluate Jacobians
    x,xp = [K1,z1,a1],[K2,z2,a2]
    y,yp = [Y1,C1,I1,N1],[Y2,C2,I2,N2]
    fx,fxp,fy,fyp = anal_deriv_first(f,x,xp,y,yp)

    # Construct perturbation matrices
    gx, hx, exitflag = gx_hx(fy,fx,fyp,fxp)

    # State-Space Matrices
    A = np.zeros((2,1))
    B = np.array([[gx[0,:]],[gx[1,:]]])
    H = np.zeros((2,2))
    R = np.array([np.zeros((1,2)),[psigz,0],[0,psiga]])
    Se = np.eye(2)
    Phi = hx

    return x,xp,y,yp,f,fx,fxp,fy,fyp

